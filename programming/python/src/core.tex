\section{Core}

\begin{tabularx}{\linewidth}{lX}
    \texttt{help()}                 & Help about a module or function.\\
                                    & Eg: \texttt{import numpy as np}\\
                                    & Eg: \texttt{help(np)}\\
                                    & Eg: \texttt{help(np.sort)}\\
    \hline
    \texttt{.\_\_name\_\_}          & Name of an object, function, module, etc.\\
                                    & Eg: \texttt{foo.\_\_name\_\_ \# Returns 'foo'}.\\ 
                                    & Eg: \texttt{f = foo}\\
                                    & Eg: \texttt{f.\_\_name\_\_ \# Returns 'foo'}.\\
    \texttt{id(x)}                  & Gives the address of the variable \texttt{x}.\\ 
                                    & Can be used to check if two variables point to the same object.\\
                                    & The address cannot be derefenced like a C pointer.\\
    \texttt{isinstance()}           & Eg: \texttt{isinstance(x, str)}, returns true if x is a string.\\
                                    & \texttt{isinstance(x, (str, int))}, returns true if x is either a string or an integer.\\
    \texttt{del()}                  & Delete objects.\\
    \hline
    \texttt{globals()}              & Gives dictionary representing the global symbol table.\\
    \quad\texttt{.get()}            & Get object by name.\\
                                    & Eg: \texttt{bar = globals.get('foo')}.\\
    \texttt{global}                 & Declares and object as a global variable.\\
                                    & Eg: \texttt{global foo}. But, \texttt{global foo = 2}, does not work.\\
                                    & Assignment during global declaration does not work. Also see list comprehension.\\
    \hline
    *                               & Unpacks a sequence like a list or tuple to function arguments.\\
                                    & Eg: \texttt{l = [1, 2, 3]}\\
                                    & Eg: \texttt{foo(*l)}\\
                                    & Eg: \texttt{a, *b, c = [1, 2, 3, 4, 5] \# b = [2, 3, 4]}\\
    **                              & Upacks a dictionary into keyword arguments.\\
                                    & Eg: \texttt{kwargs = {'a': 1,'b' = 2}}.\\
                                    & Eg: \texttt{foo(**kwargs)}\\
                                    & Inside function foo \texttt{a} and \texttt{b} becomes variables with
                                      values \texttt{1} and \texttt{2} respectively.\\
    \hline
    \texttt{zip}                    & Zip two iterables.\\
                                    & Eg: \texttt{x = [1, 2]}.\\
                                    & Eg: \texttt{y = [3, 4]}.\\
                                    & Eg: \texttt{w = list(zip(x, y))}.\\
                                    & Eg: \texttt{w = [(1, 3), (2, 4)]}.\\
    \texttt{enumerate}              & Enumerate iterables.\\ 
                                    & Eg: \texttt{for id, x in enumerate(l):}.\\
                                    & Eg: \texttt{for id, (x, y) in enumerate(zip(l1, l2)):}.\\
    \hline
    \texttt{eval}                   & Evaluate a string expressions.\\
                                    & Eg: \texttt{eval('1 + 2')}. Returns 3.\\
    \hline
\end{tabularx}


\columnbreak

\textcolor{red}{Caution: }\textbf{A note on circular imports.}\\
When two modules import from each other it causes unexpected behaviour. Strategies to avoid circular imports:
\begin{enumerate}
\item Refactor shared functionalities to a distinct module.
\item Use local imports. 
\item Use lazy imports: \texttt{importlib.import\_module()}.
\end{enumerate}


\subsubsection{List comprehensions}
\begin{itemize}
\item \textbf{Basic Syntax.}\\
            \texttt{[f(x) for x in iterable]}.
            Eg: \texttt{[x ** 2 for x in range(4)]}\\
            \texttt{[0, 1, 4, 9]}
\item \textbf{With conditions.}\\ 
            \texttt{[x ** 2 if x\%2==0 else 2 * x for x in range(10)]}\\
            \texttt{[0, 2, 4, 6]}
\item \textbf{Filtering items by condition.}\\
            \texttt{[x ** 2 for x in range(10) if x\%2==0]}\\
            \texttt{[0, 4]}
\item \textbf{Nested list.}\\
            \texttt{[(x, y) for x in [1, 2] for y in [3, 4]]}\\
            \texttt{[(1, 3), (1, 4), (2, 3), (2, 4)]}
\item \textbf{Flattening a list.}\\
            \texttt{m = [[1, 2], [3, 4]]}\\
            \texttt{[x for v in m for x in v]}\\
            \texttt{[1, 2, 3, 4]}
\end{itemize}



\subsubsection{Special Variables and Naming Conventions}

\begin{tabularx}{\linewidth}{lX}
\texttt{\_foo}                  & Internal use. Not for public access.\\
\texttt{\_\_foo}                & Name mangling to prevent accidental overrides. Interpreter changes
                                    the name to prevent override in child class.\\
\texttt{\_\_foo\_\_}            & Special variables that are part of python, don't create your own.\\
\texttt{foo\_}                  & To avoid conflict with keywords.\\
\hline
\texttt{\_\_file\_\_}           & Path to current script of file.\\
\texttt{\_\_name\_\_}           & Name of the module or \texttt{"\_\_main\_\_"} if run directly.\\
                                & Eg: If the script is \texttt{foo.py}\\
                                & Then \texttt{\_\_name\_\_ == "foo"}.\\
\texttt{\_\_version\_\_}        & Version of the module. Does not work for all (eg: os).\\
                                & Eg: \texttt{np.\_\_version\_\_}.\\
                                & Eg: \texttt{os.\_\_version\_\_}. This does not work.\\
\hline
\end{tabularx}



\textcolor{red}{TODO: Generators, }

\columnbreak