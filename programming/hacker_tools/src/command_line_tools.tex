\section{Command Line Tools}

\subsubsection{Files \& Directories}

%\textbf{Files and Directories}
\begin{tabularx}{\linewidth}{lX}
    % Navigate and explore.
    \texttt{cd} & Change directory.\\
    \texttt{pwd} & Print working directory\\
    \texttt{ls} & Options: \texttt{-Ralh} \\
    \texttt{tree} & List in tree form. eg: \texttt{tree \textit{dir}}\\
    \hline

    % Manipulate files and directories.
    \texttt{touch} & Creates text file. \\
    \texttt{mkdir} & Make directory\\
    \texttt{mkdir -p} & Make directory and necessary parent dir.\\
    \texttt{cp} & Copy files.\\
    \texttt{mv} & To move files and rename files.\\
    \texttt{rm} & Remove files permanently. \\
    \texttt{rm -i} & Remove files interactively. \\
    \texttt{rm -r, rm -R} & Remove files recursively. Use to delete folders.\\
    \texttt{rm -f} & Force delete.\\
    \texttt{basename} & Removes folder name from path and optionally  suffix.\\
    \texttt{-s} & Remove suffix. eg: \texttt{basename -s .fastq $<$\textit{path}$>$}\\
    \hline

    % Common aliases.
    \texttt{\~} & Home directory, aka \texttt{\$HOME}.\\
    \texttt{./ , ../} & Relative paths to current and parent dir.\\
    \texttt{/dev/null} & Fake file, black box.\\ 
    \hline

    %
    % File permissions.
    \texttt{chmod 777}              & r-4,w-2,x-1. User, group,all.  \\
    \texttt{chmod xyz}              & Eg \texttt{chmod u+w}.\\
                                    & x = \texttt{u} : user, \texttt{g} : group, \texttt{a} : all.\\
                                    & y = \texttt{+} : add, \texttt{-} : remove.\\
                                    & z = \texttt{r} : read, \texttt{w} : write, \texttt{x} : execute.\\
    \hline

    % Disk usage. 
    \texttt{du -h \textit{dir}}     & Gives size of all directories in \texttt{\textit{dir}}\\
    \texttt{du -sh \textit{dir}}    & Gives size of \texttt{\textit{dir}}.\\
    \texttt{df -h}                  & Gives information about disk usage.\\
    \hline

\end{tabularx}

\subsubsection{File compression}


\begin{tabularx}{\linewidth}{lX}

    \texttt{tar}            & Tape archive\\
    \texttt{-cf}            & To make tar file form a directory \texttt{tar -cf dir.tar dir}.\\
    \texttt{-tf}            & View contents of an archive.\\
    \texttt{-tvf}           & View contents, verbose.\\
    \texttt{-xf}            & extract.\\
    \hline

    \texttt{zip -r}         & Compress. \texttt{zip -r file.zip dir}\\
    \texttt{unzip -l}       & View contents. \texttt{unzip -l file.zip}\\
    \texttt{unzip}          & Decompress. \texttt{unzip file.zip}\\
    \hline

    \texttt{gzip}           & Eg: \texttt{gzip filename}. \texttt{gzip} can only compress a file and not a directory. To compress a directory first make a .tar file and then compress that.\\
    \texttt{gunzip}         & To unzip .gz files.\\
    \texttt{-c}             & Output to standard output. \\
                            & Eg: \texttt{gzip -c file1 >  file.gz}. Eg: \texttt{gzip -c file2 >> file.gz}. and \texttt{gunzip -c}.\\
    \texttt{bzip2}          & Works like gzip. Higher compression, but slow. File extension \texttt{.bz2}\\
    \hline

\end{tabularx}


\textcolor{red}{TODO: chown, chgrp.}
\textcolor{red}{\texttt{compress}/\texttt{uncompress}. Also: \texttt{zgrep}, \texttt{zcat}, \texttt{zless}, \texttt{zdiff}}
\textcolor{red}{rsync}\\
\textcolor{red}{hexdump, checksums, diff (in text processing?).}\\

\subsubsection{Process Execution}

\begin{tabularx}{\linewidth}{lX}
    % Processes execution.

    \texttt{Cmd1 ; Cmd2}        & Run Cmd2 irrespective of exit status of Cmd1.\\
    \texttt{Cmd1 || Cmd2}       & Execute \texttt{Prog2} only if \texttt{Prog1} has failed (non-zero exit status).\\
    \texttt{Cmd1 \&\& Cmd2}     & Execute \texttt{Prog2} only if \texttt{Prog1} has succeded (zero exit status).\\
    \texttt{(...;...)|...}      & Subshell: Both commands separated by a semicolon are processed independently and piped in parallel to next step. \\
    \texttt{<(...)}             & Process substitution, like anonymous named pipe. Eg: \texttt{program --in1 <(...) --in2 <(...) }.\\
    \texttt{>(...)}             & Write output to anonymous named pipe. Eg: \texttt{program --out1 >(...) --out2 >(...)}.\\
    \hline

    %xargs
    \texttt{xargs}              & Execute command from stdin. \textbf{Examples:}\\
                                & \textit{Apply wc on each file.}\\
                                & \texttt{ls *.txt | xargs wc}\\
                                & \textit{Apply wc on each file, using placeholder.}\\
                                & \texttt{ls *.txt | xargs -I \{\} wc \{\}}.\\
                                & \textit{List all files in each dir, with the dirname. [Two ways.]}\\
                                & \texttt{ls | xargs -I \{\} sh -c 'echo \{\}; echo "---"; ls \{\}'}\\
                                & \texttt{ls | xargs -I \{\} sh -c 'echo \$1; echo "---"; ls \$1'} \_ \{\}\\
    \hline

    % Pipelines.
    $\mid$                           & Pipe output to another program.\\
    \texttt{mkfifo}             & Create a named pipe. Eg: \texttt{mkfifo fqin}. Treat named pipe like any other file. But the input and output is piped. While using named pipe nothing is written on the disk.\\

    % Background and persistent processes.
    \texttt{nohup}              & Run a program without interruption.\\
    \texttt{\&}                 & Run in background. eg: \texttt{nohup prog1 \&}\\
    \hline

\end{tabularx}


\subsubsection{Process mangement}

\begin{tabularx}{\linewidth}{lX}
    % Job control.
    \texttt{jobs}           & List all jobs. Use id in [] to bg,fg,kill. \\
    \texttt{fg}             & Bring a job to foreground.\\
    \texttt{bf}             & Resume a suspended process in the background.\\
    \keys{ctrl} + \keys{z}  & Pause a running job.\\
    \keys{ctrl} + \keys{c}  & Kill a running job.\\
    \texttt{kill}           & End a job.\\
    \texttt{echo \$?}       & Exit status,=0 when a program exits without an error.\\
    \hline

    % System monitoring.
    \texttt{top}            & Display tasks and system resource usage.\\
    \texttt{htop}           & User friendly tool to view running processes and resource utilization.\\
    \hline
\end{tabularx}


\subsubsection{Etc}

\begin{tabularx}{\linewidth}{lX}
    % find.
    \texttt{find}           & Find file/directories.\\
                            & Pattern: \texttt{find <dir> <iname/name> "<patttern>"}\\
                            & Eg: \texttt{find . -iname "*deviceQuery"}\\
    \hline
    
    % Pattern matching.
    \texttt{?,*, [A-Z]} & Wild cards.\\
    \texttt{\{\}} & Expands combinatorially.\\ 
    &  Eg: \texttt{\$ mkdir mm10-\{chr1,chr2,chr3\}}\\
    \$() & Eg: \texttt{echo "...\$(...)..."}\\
    & Eg: \texttt{mkdir results-\$(date +\%F)}\\
    & Eg: \texttt{\$ today = "date + \%F"}. \\
    \hline

\end{tabularx}

\vfill\null
\columnbreak 

\begin{tabularx}{\linewidth}{lX}

\end{tabularx}


\subsubsection{Terminal customization}

\begin{tabularx}{\linewidth}{lX}
    \texttt{alias x ="..."}             & Store new commands. But in shell startup file eg \texttt{\~{}/.profile} or \texttt{\~{}/.bashrc} and it is temporary.\\
    Directory depth                     & To trim the path shown in terminal:\\
                                        & \texttt{PROMPT\_DIRTRIM=1}\\
                                        & \texttt{1} indicates a depth of 1.\\
\end{tabularx}

\textcolor{red}{TODO: export, \$PATH, source}


\vfill\null
\columnbreak